---
interface Props {
  title: string;
}

const { title } = Astro.props;
import Navbar from "../components/Navbar.astro";
---

<style>
  #canvas {
    position: fixed;
    top: 0;
    left: 0;
    display: block;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
</style>

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Astro description" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body
    class="bg-gradient-to-b from-black to-neutral-800 min-h-screen text-neutral-100"
  >
    <canvas id="canvas"></canvas>
    <Navbar />
    <slot />
  </body>
</html>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    window.requestAnimFrame = (function () {
      return (
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (/* function */ callback) {
          window.setTimeout(callback, 1000 / 60);
        }
      );
    })();

    var canvas = document.getElementById("canvas") as HTMLCanvasElement;

    if (!canvas) {
      console.error("Canvas element not found!");
      return;
    }

    var context = canvas.getContext("2d");

    if (!context) {
      console.error("Context not found!");
      return;
    }

    // Get DPI
    let dpi: number = window.devicePixelRatio || 1;
    context.scale(dpi, dpi);

    function fix_dpi() {
      // Get CSS height
      // The "+"" prefix casts it to an integer
      // The slice method gets rid of "px"
      let style_height = +getComputedStyle(canvas)
        .getPropertyValue("height")
        .slice(0, -2);
      let style_width = +getComputedStyle(canvas)
        .getPropertyValue("width")
        .slice(0, -2);

      // Scale the canvas
      canvas.setAttribute("height", (style_height * dpi).toString());
      canvas.setAttribute("width", (style_width * dpi).toString());
    }

    var particle_count = 70,
      particles = [],
      colors = ["#27374D", "#526D82", "#9DB2BF", "#DDE6ED"];
    function Particle() {
      this.radius = Math.round(Math.random() * 3 + 5);
      this.x = Math.floor(
        Math.random() *
          (+getComputedStyle(canvas).getPropertyValue("width").slice(0, -2) *
            dpi -
            this.radius +
            1) +
          this.radius
      );
      this.y = Math.floor(
        Math.random() *
          (+getComputedStyle(canvas).getPropertyValue("height").slice(0, -2) *
            dpi -
            this.radius +
            1) +
          this.radius
      );
      this.color = colors[Math.floor(Math.random() * colors.length)];
      this.speedx = Math.round(Math.random() * 201 + 0) / 100;
      this.speedy = Math.round(Math.random() * 201 + 0) / 100;

      switch (Math.round(Math.random() * colors.length)) {
        case 1:
          this.speedx *= 1;
          this.speedy *= 1;
          break;
        case 2:
          this.speedx *= -1;
          this.speedy *= 1;
          break;
        case 3:
          this.speedx *= 1;
          this.speedy *= -1;
          break;
        case 4:
          this.speedx *= -1;
          this.speedy *= -1;
          break;
      }

      this.move = function () {
        context.beginPath();
        context.globalCompositeOperation = "source-over";
        context.fillStyle = this.color;
        context.globalAlpha = 1;
        context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        context.fill();
        context.closePath();

        this.x = this.x + this.speedx;
        this.y = this.y + this.speedy;

        if (this.x <= 0 + this.radius) {
          this.speedx *= -1;
        }
        if (this.x >= canvas.width - this.radius) {
          this.speedx *= -1;
        }
        if (this.y <= 0 + this.radius) {
          this.speedy *= -1;
        }
        if (this.y >= canvas.height - this.radius) {
          this.speedy *= -1;
        }

        for (var j = 0; j < particle_count; j++) {
          var currParticle = particles[j],
            yd = currParticle.y - this.y,
            xd = currParticle.x - this.x,
            d = Math.sqrt(xd * xd + yd * yd);

          if (d < 200) {
            context.beginPath();
            context.globalAlpha = (200 - d) / (200 - 0);
            context.globalCompositeOperation = "destination-over";
            context.lineWidth = 1;
            context.moveTo(this.x, this.y);
            context.lineTo(currParticle.x, currParticle.y);
            context.strokeStyle = this.color;
            context.lineCap = "round";
            context.stroke();
            context.closePath();
          }
        }
      };
    }
    for (var i = 0; i < particle_count; i++) {
      fix_dpi();
      var particle = new Particle();
      particles.push(particle);
    }

    function animate() {
      fix_dpi();
      context.clearRect(0, 0, canvas.width, canvas.height);
      for (var i = 0; i < particle_count; i++) {
        particles[i].move();
      }
      requestAnimFrame(animate);
    }

    animate();
  });
</script>
